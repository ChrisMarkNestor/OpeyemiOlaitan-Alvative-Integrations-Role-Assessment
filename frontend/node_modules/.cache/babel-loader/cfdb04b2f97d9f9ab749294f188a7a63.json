{"ast":null,"code":"import _slicedToArray from \"/home/ezikechris/Documents/OpeyemiOlaitan-Alvative-Integrations-Role-Assessment/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty2 from \"/home/ezikechris/Documents/OpeyemiOlaitan-Alvative-Integrations-Role-Assessment/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport react, { createContext, useReducer, useEffect, useMemo, useContext } from 'react';\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\nvar common = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  function fromStorage(value) {\n    return value !== null ? JSON.parse(value) : null;\n  }\n  function readItem(storage, key) {\n    try {\n      var storedValue = storage.getItem(key);\n      return fromStorage(storedValue);\n    } catch (e) {\n      return null;\n    }\n  }\n  function toStorage(value) {\n    return JSON.stringify(value);\n  }\n  function writeItem(storage, key, value) {\n    try {\n      if (value !== null) {\n        storage.setItem(key, toStorage(value));\n      } else {\n        storage.removeItem(key);\n      }\n      return Promise.resolve();\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  function useInitialState(storage, key, defaultState) {\n    var defaultStateRef = react.useRef(defaultState);\n    return react.useMemo(function () {\n      var _a;\n      return (_a = readItem(storage, key)) !== null && _a !== void 0 ? _a : defaultStateRef.current;\n    }, [key, storage]);\n  }\n  exports.useInitialState = useInitialState;\n  function useStorageWriter(storage, key, state) {\n    var _a = react.useState(undefined),\n      writeError = _a[0],\n      setWriteError = _a[1];\n    react.useEffect(function () {\n      writeItem(storage, key, state).catch(function (error) {\n        if (!error || !error.message || error.message !== (writeError === null || writeError === void 0 ? void 0 : writeError.message)) {\n          setWriteError(error);\n        }\n      });\n      if (writeError) {\n        return function () {\n          setWriteError(undefined);\n        };\n      }\n    }, [state, key, writeError, storage]);\n    return writeError;\n  }\n  exports.useStorageWriter = useStorageWriter;\n  function useStorageListener(storage, key, defaultState, onChange) {\n    var defaultStateRef = react.useRef(defaultState);\n    var onChangeRef = react.useRef(onChange);\n    var firstRun = react.useRef(true);\n    react.useEffect(function () {\n      var _a;\n      if (firstRun.current) {\n        firstRun.current = false;\n        return;\n      }\n      onChangeRef.current((_a = readItem(storage, key)) !== null && _a !== void 0 ? _a : defaultStateRef.current);\n    }, [key, storage]);\n    react.useEffect(function () {\n      function onStorageChange(event) {\n        var _a;\n        if (event.key === key) {\n          onChangeRef.current((_a = fromStorage(event.newValue)) !== null && _a !== void 0 ? _a : defaultStateRef.current);\n        }\n      }\n      if (typeof window !== 'undefined') {\n        window.addEventListener('storage', onStorageChange);\n        return function () {\n          window.removeEventListener('storage', onStorageChange);\n        };\n      }\n    }, [key]);\n  }\n  exports.useStorageListener = useStorageListener;\n});\nunwrapExports(common);\nvar common_1 = common.useInitialState;\nvar common_2 = common.useStorageWriter;\nvar common_3 = common.useStorageListener;\nvar state = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  function useStorageState(storage, key, defaultState) {\n    if (defaultState === void 0) {\n      defaultState = null;\n    }\n    var _a = react.useState(common.useInitialState(storage, key, defaultState)),\n      state = _a[0],\n      setState = _a[1];\n    common.useStorageListener(storage, key, defaultState, setState);\n    var writeError = common.useStorageWriter(storage, key, state);\n    return [state, setState, writeError];\n  }\n  exports.default = useStorageState;\n});\nunwrapExports(state);\nvar reducer = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  var FORCE_STATE_ACTION = '__FORCE_STATE_INTERNAL_API__';\n  function isForceStateAction(action) {\n    return typeof action === 'object' && action !== null && 'type' in action && action.type === FORCE_STATE_ACTION;\n  }\n  function addForceStateActionToReducer(reducer) {\n    return function (state, action) {\n      if (isForceStateAction(action)) return action.payload;\n      return reducer(state, action);\n    };\n  }\n  function useStorageReducer(storage, key, reducer, defaultInitialArg, defaultInit) {\n    if (defaultInit === void 0) {\n      defaultInit = function defaultInit(x) {\n        return x;\n      };\n    }\n    var defaultState = defaultInit(defaultInitialArg);\n    var _a = react.useReducer(addForceStateActionToReducer(reducer), common.useInitialState(storage, key, defaultState)),\n      state = _a[0],\n      dispatch = _a[1];\n    common.useStorageListener(storage, key, defaultState, function (newValue) {\n      dispatch({\n        type: FORCE_STATE_ACTION,\n        payload: newValue\n      });\n    });\n    var writeError = common.useStorageWriter(storage, key, state);\n    return [state, dispatch, writeError];\n  }\n  exports.default = useStorageReducer;\n});\nunwrapExports(reducer);\nvar dist = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.useStorageState = state.default;\n  exports.useStorageReducer = reducer.default;\n});\nunwrapExports(dist);\nvar dist_1 = dist.useStorageState;\nvar dist_2 = dist.useStorageReducer;\nvar isClient = typeof window === 'object';\nvar formatCurrencyString = function formatCurrencyString(_ref) {\n  var value = _ref.value,\n    currency = _ref.currency,\n    _ref$language = _ref.language,\n    language = _ref$language === void 0 ? isClient ? navigator.language : 'en-US' : _ref$language;\n  value = parseInt(value);\n  var numberFormat = new Intl.NumberFormat(language, {\n    style: 'currency',\n    currency: currency,\n    currencyDisplay: 'symbol'\n  });\n  var parts = numberFormat.formatToParts(value);\n  var zeroDecimalCurrency = true;\n  var _iterator = _createForOfIteratorHelper(parts),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var part = _step.value;\n      if (part.type === 'decimal') {\n        zeroDecimalCurrency = false;\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  value = zeroDecimalCurrency ? value : value / 100;\n  return numberFormat.format(value.toFixed(2));\n};\nfunction useLocalStorageReducer(key, reducer, initialState) {\n  var dummyStorage = {\n    getItem: function getItem() {\n      return null;\n    },\n    setItem: function setItem() {},\n    removeItem: function removeItem() {}\n  };\n  return dist_2(isClient ? window.localStorage : dummyStorage, key, reducer, initialState);\n}\nvar getCheckoutData = {\n  stripe: function stripe(cart) {\n    var _cart$allowedCountrie;\n    var lineItems = [];\n    for (var sku in cart.cartDetails) {\n      lineItems.push({\n        price: sku,\n        quantity: cart.cartDetails[sku].quantity\n      });\n    }\n    var options = {\n      mode: 'payment',\n      lineItems: lineItems,\n      successUrl: cart.successUrl,\n      cancelUrl: cart.cancelUrl,\n      billingAddressCollection: cart.billingAddressCollection ? 'required' : 'auto',\n      submitType: 'auto'\n    };\n    if ((_cart$allowedCountrie = cart.allowedCountries) === null || _cart$allowedCountrie === void 0 ? void 0 : _cart$allowedCountrie.length) {\n      options.shippingAddressCollection = {\n        allowedCountries: cart.allowedCountries\n      };\n    }\n    return options;\n  }\n};\nfunction checkoutHandler(cart, checkoutOptions) {\n  var serviceProperty = '';\n  if (cart.stripe) serviceProperty = 'stripe';\n  var needsCheckoutData = cart.mode === 'client-only';\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(parameters) {\n      var options, _yield$checkoutOption, error;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (serviceProperty) {\n              _context.next = 2;\n              break;\n            }\n            throw new Error('No compatible API has been defined, your options are: Stripe');\n          case 2:\n            if (checkoutOptions.modes.includes(cart.mode)) {\n              _context.next = 4;\n              break;\n            }\n            throw new Error(\"Invalid checkout mode '\".concat(cart.mode, \"' was chosen. The valid modes are \").concat(new Intl.ListFormat().format(checkoutOptions.modes), \".\"));\n          case 4:\n            options = {\n              sessionId: parameters === null || parameters === void 0 ? void 0 : parameters.sessionId\n            };\n            if (needsCheckoutData) options = getCheckoutData.stripe(cart);\n            _context.t0 = checkoutOptions;\n            _context.t1 = serviceProperty;\n            _context.next = 10;\n            return cart[serviceProperty];\n          case 10:\n            _context.t2 = _context.sent;\n            _context.t3 = options;\n            _context.t4 = parameters;\n            _context.next = 15;\n            return _context.t0[_context.t1].call(_context.t0, _context.t2, _context.t3, _context.t4);\n          case 15:\n            _yield$checkoutOption = _context.sent;\n            error = _yield$checkoutOption.error;\n            if (!error) {\n              _context.next = 19;\n              break;\n            }\n            return _context.abrupt(\"return\", error);\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function (_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}\nvar cartInitialState = {\n  lastClicked: '',\n  shouldDisplayCart: false,\n  stripe: null\n};\nfunction cartReducer(cart, action) {\n  switch (action.type) {\n    case 'store-last-clicked':\n      return _objectSpread2(_objectSpread2({}, cart), {}, {\n        lastClicked: action.sku\n      });\n    case 'cart-click':\n      return _objectSpread2(_objectSpread2({}, cart), {}, {\n        shouldDisplayCart: !cart.shouldDisplayCart\n      });\n    case 'cart-hover':\n      return _objectSpread2(_objectSpread2({}, cart), {}, {\n        shouldDisplayCart: true\n      });\n    case 'close-cart':\n      return _objectSpread2(_objectSpread2({}, cart), {}, {\n        shouldDisplayCart: false\n      });\n    case 'stripe-changed':\n      return _objectSpread2(_objectSpread2({}, cart), {}, {\n        stripe: action.stripe\n      });\n    default:\n      return cart;\n  }\n}\nvar cartValuesInitialState = {\n  cartDetails: {},\n  totalPrice: 0,\n  cartCount: 0\n};\nfunction Entry(productData, quantity, currency, language) {\n  return _objectSpread2(_objectSpread2({}, productData), {}, {\n    quantity: quantity,\n    get value() {\n      return this.price * this.quantity;\n    },\n    get formattedValue() {\n      return formatCurrencyString({\n        value: this.value,\n        currency: currency,\n        language: language\n      });\n    }\n  });\n}\nfunction cartValuesReducer(state, action) {\n  function createEntry(product, count) {\n    var entry = Entry(product, count, action.currency, action.language);\n    return {\n      cartDetails: _objectSpread2(_objectSpread2({}, state.cartDetails), {}, _defineProperty2({}, product.sku, entry)),\n      totalPrice: state.totalPrice + product.price * count,\n      cartCount: state.cartCount + count\n    };\n  }\n  function updateEntry(sku, count) {\n    var cartDetails = _objectSpread2({}, state.cartDetails);\n    var entry = cartDetails[sku];\n    if (entry.quantity + count <= 0) return removeEntry(sku);\n    cartDetails[sku] = Entry(entry, entry.quantity + count, action.currency, action.language);\n    return {\n      cartDetails: cartDetails,\n      totalPrice: state.totalPrice + entry.price * count,\n      cartCount: state.cartCount + count\n    };\n  }\n  function removeEntry(sku) {\n    var cartDetails = _objectSpread2({}, state.cartDetails);\n    var totalPrice = state.totalPrice - cartDetails[sku].value;\n    var cartCount = state.cartCount - cartDetails[sku].quantity;\n    delete cartDetails[sku];\n    return {\n      cartDetails: cartDetails,\n      totalPrice: totalPrice,\n      cartCount: cartCount\n    };\n  }\n  function updateQuantity(sku, quantity) {\n    var entry = state.cartDetails[sku];\n    return updateEntry(sku, quantity - entry.quantity);\n  }\n  switch (action.type) {\n    case 'add-item-to-cart':\n      if (action.count <= 0) break;\n      if (action.product.sku in state.cartDetails) return updateEntry(action.product.sku, action.count);\n      return createEntry(action.product, action.count);\n    case 'increment-item':\n      if (action.count <= 0) break;\n      if (action.sku in state.cartDetails) return updateEntry(action.sku, action.count);\n      break;\n    case 'decrement-item':\n      if (action.count <= 0) break;\n      if (action.sku in state.cartDetails) return updateEntry(action.sku, -action.count);\n      break;\n    case 'set-item-quantity':\n      if (action.count < 0) break;\n      if (action.sku in state.cartDetails) return updateQuantity(action.sku, action.quantity);\n      break;\n    case 'remove-item-from-cart':\n      if (action.sku in state.cartDetails) return removeEntry(action.sku);\n      break;\n    case 'clear-cart':\n      return cartValuesInitialState;\n    default:\n      return state;\n  }\n  console.warn('Invalid action arguments', action);\n  return state;\n}\nvar CartContext = createContext([_objectSpread2({\n  lastClicked: '',\n  shouldDisplayCart: false\n}, cartValuesInitialState), function () {}]);\nvar CartProvider = function CartProvider(_ref) {\n  var children = _ref.children,\n    mode = _ref.mode,\n    stripe = _ref.stripe,\n    successUrl = _ref.successUrl,\n    cancelUrl = _ref.cancelUrl,\n    currency = _ref.currency,\n    _ref$language2 = _ref.language,\n    language = _ref$language2 === void 0 ? isClient ? navigator.language : 'en-US' : _ref$language2,\n    _ref$billingAddressCo = _ref.billingAddressCollection,\n    billingAddressCollection = _ref$billingAddressCo === void 0 ? false : _ref$billingAddressCo,\n    _ref$allowedCountries = _ref.allowedCountries,\n    allowedCountries = _ref$allowedCountries === void 0 ? null : _ref$allowedCountries;\n  var _useReducer = useReducer(cartReducer, cartInitialState),\n    _useReducer2 = _slicedToArray(_useReducer, 2),\n    cart = _useReducer2[0],\n    cartDispatch = _useReducer2[1];\n  useEffect(function () {\n    cartDispatch({\n      type: 'stripe-changed',\n      stripe: stripe\n    });\n  }, [stripe]);\n  var _useLocalStorageReduc = useLocalStorageReducer('cart-values', cartValuesReducer, cartValuesInitialState),\n    _useLocalStorageReduc2 = _slicedToArray(_useLocalStorageReduc, 2),\n    cartValues = _useLocalStorageReduc2[0],\n    cartValuesDispatch = _useLocalStorageReduc2[1]; // combine dispatches and\n  // memoize context value to avoid causing re-renders\n\n  var contextValue = useMemo(function () {\n    return [_objectSpread2(_objectSpread2(_objectSpread2({}, cart), cartValues), {}, {\n      mode: mode,\n      successUrl: successUrl,\n      cancelUrl: cancelUrl,\n      currency: currency,\n      language: language,\n      billingAddressCollection: billingAddressCollection,\n      allowedCountries: allowedCountries\n    }), function (action) {\n      cartDispatch(action);\n      cartValuesDispatch(_objectSpread2(_objectSpread2({}, action), {}, {\n        currency: currency,\n        language: language\n      }));\n    }];\n  }, [cart, cartDispatch, cartValues, cartValuesDispatch, mode, successUrl, cancelUrl, currency, language, billingAddressCollection, allowedCountries]);\n  return /*#__PURE__*/react.createElement(CartContext.Provider, {\n    value: contextValue\n  }, children);\n};\nvar useShoppingCart = function useShoppingCart() {\n  var _useContext = useContext(CartContext),\n    _useContext2 = _slicedToArray(_useContext, 2),\n    cart = _useContext2[0],\n    dispatch = _useContext2[1];\n  var lastClicked = cart.lastClicked,\n    shouldDisplayCart = cart.shouldDisplayCart,\n    cartCount = cart.cartCount,\n    cartDetails = cart.cartDetails,\n    totalPrice = cart.totalPrice,\n    currency = cart.currency,\n    language = cart.language;\n  var addItem = function addItem(product) {\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return dispatch({\n      type: 'add-item-to-cart',\n      product: product,\n      count: count\n    });\n  };\n  var removeItem = function removeItem(sku) {\n    return dispatch({\n      type: 'remove-item-from-cart',\n      sku: sku\n    });\n  };\n  var setItemQuantity = function setItemQuantity(sku, quantity) {\n    return dispatch({\n      type: 'set-item-quantity',\n      sku: sku,\n      quantity: quantity\n    });\n  };\n  var incrementItem = function incrementItem(sku) {\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return dispatch({\n      type: 'increment-item',\n      sku: sku,\n      count: count\n    });\n  };\n  var decrementItem = function decrementItem(sku) {\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return dispatch({\n      type: 'decrement-item',\n      sku: sku,\n      count: count\n    });\n  };\n  var clearCart = function clearCart() {\n    return dispatch({\n      type: 'clear-cart'\n    });\n  };\n  var storeLastClicked = function storeLastClicked(sku) {\n    return dispatch({\n      type: 'store-last-clicked',\n      sku: sku\n    });\n  };\n  var handleCartClick = function handleCartClick() {\n    return dispatch({\n      type: 'cart-click'\n    });\n  };\n  var handleCartHover = function handleCartHover() {\n    return dispatch({\n      type: 'cart-hover'\n    });\n  };\n  var handleCloseCart = function handleCloseCart() {\n    return dispatch({\n      type: 'close-cart'\n    });\n  };\n  var redirectToCheckout = checkoutHandler(cart, {\n    modes: ['client-only', 'checkout-session'],\n    stripe: function stripe(_stripe, options) {\n      return _stripe.redirectToCheckout(options);\n    }\n  });\n  var checkoutSingleItem = checkoutHandler(cart, {\n    modes: ['client-only'],\n    stripe: function stripe(_stripe2, options, _ref2) {\n      var sku = _ref2.sku,\n        _ref2$quantity = _ref2.quantity,\n        quantity = _ref2$quantity === void 0 ? 1 : _ref2$quantity;\n      options.lineItems = [{\n        price: sku,\n        quantity: quantity\n      }];\n      return _stripe2.redirectToCheckout(options);\n    }\n  });\n  return {\n    cartDetails: cartDetails,\n    cartCount: cartCount,\n    totalPrice: totalPrice,\n    get formattedTotalPrice() {\n      return formatCurrencyString({\n        value: totalPrice,\n        currency: currency,\n        language: language\n      });\n    },\n    addItem: addItem,\n    removeItem: removeItem,\n    setItemQuantity: setItemQuantity,\n    incrementItem: incrementItem,\n    decrementItem: decrementItem,\n    clearCart: clearCart,\n    lastClicked: lastClicked,\n    storeLastClicked: storeLastClicked,\n    shouldDisplayCart: shouldDisplayCart,\n    handleCartClick: handleCartClick,\n    handleCartHover: handleCartHover,\n    handleCloseCart: handleCloseCart,\n    redirectToCheckout: redirectToCheckout,\n    checkoutSingleItem: checkoutSingleItem\n  };\n};\nexport { CartContext, CartProvider, formatCurrencyString, isClient, useShoppingCart };","map":null,"metadata":{},"sourceType":"module"}